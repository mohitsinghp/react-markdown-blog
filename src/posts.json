[{"id":1657996200,"title":"Array.prototype.function()\r","author":"MSP\r","date":"July 17, 2022\r","content":"## Function Syntax\r\n\r\nA function in JavaScript comprises of three statements.\r\n\r\n* The name of the function.\r\n* A list of arguments to the function enclosed in parentheses and separated by commas.\r\n* The JavaScript statements that define the function, enclosed\r\n\r\nFunction in Javascript is defined in a number of ways. the common function definition is\r\n```js\r\nfunction function_name(arg1,arg2,...) {\r\n//operation to be carried out by the function\r\n}\r\n```\r\n\r\n## Prototype\r\n\r\nPrototypes are the mechanism by which JavaScript objects inherit features from one another.\r\n\r\nJavaScript is often described as a prototype-based language — to provide inheritance, objects can have a prototype object, which acts as a template object that it inherits methods and properties from.\r\n\r\nIn JavaScript, a link is made between the object instance and its prototype, and the properties and methods are found by walking up the chain of prototypes.\r\n\r\n## My forEach\r\n\r\nThe ***`myForEach()`*** method calls a provided callback function once for each element in an array in ascending order.\r\n\r\n* **`callback`** - Function to execute on each element. It accepts between one and three arguments:\r\n    * ***`currentValue`*** - The current element being processed in the array.\r\n    * ***`index Optional`*** - The index currentValue in the array.\r\n    * ***`array Optional`*** - The array myForEach() was called upon.\r\n\r\n```js\r\nArray.prototype.myForEach = function(f) {\r\nfor (let i = 0; i < this.length; i++) {\r\nf(this[i], i ,this);\r\n}\r\n}\r\n```\r\nExample :-\r\n```js\r\nmyArray = [1, 2, 3, 4];\r\nmyArray.myForEach((item,index,arr) => {\r\nconsole.log(item, index, arr);\r\n})\r\n```\r\nThis results in -\r\n```js\r\n1 0 (4) [1, 2, 3, 4]\r\n2 1 (4) [1, 2, 3, 4]\r\n3 2 (4) [1, 2, 3, 4]\r\n4 3 (4) [1, 2, 3, 4]\r\n```\r\n\r\n## My Map\r\n\r\nThe ***`myMap()`*** method creates a new array populated with the results of calling a provided function on every element in the calling array.\r\n\r\n* ***`callback`*** - Function to execute on each element. It accepts between one and three arguments:\r\n    * ***`currentValue`*** - The current element being processed in the array.\r\n    * ***`index Optional`*** - The index currentValue in the array.\r\n    * ***`array Optional`*** - The array myMap() was called upon.\r\n\r\n```js\r\nArray.prototype.myMap = function(f) {\r\nlet result = [];\r\nfor (let i = 0; i < this.length; i++) {\r\nresult.push(f(this[i], i, this));\r\n}\r\nreturn result;\r\n}\r\n```\r\nExample :-\r\n```js\r\nlet arr = [1, 2, 3, 4, 7, 14, 21]\r\nconsole.log(arr.myMap(item => item % 7 === 0));\r\n```\r\nThis reults in -\r\n```js\r\n[false, false, false, false, true, true, true,]\r\n```\r\n\r\n## My Some\r\n\r\nThe ***`mySome()`*** method tests whether at least one element in the array passes the test implemented by the provided function. It returns a Boolean value.\r\n\r\n* ***`callback`*** - Function to execute on each element. It accepts between one and three arguments:\r\n    * ***`currentValue`*** - The current element being processed in the array.\r\n    * ***`index Optional`*** - The index currentValue in the array.\r\n    * ***`array Optional`*** - The array mySome() was called upon.\r\n\r\n```js\r\nArray.prototype.mySome = function(f) {\r\nlet result = false;\r\nfor (let i = 0; i < this.length; i++) {\r\nif(f(this[i], i, this)) {\r\nresult = true;\r\n}\r\n}\r\nreturn result;\r\n}\r\n```\r\nExample :-\r\n```js\r\nlet arr = [1, 2, 3, 4, 7]\r\narr.mySome(item => item % 7 === 0);\r\n```\r\nThis results in -\r\n```js\r\ntrue\r\n```\r\n\r\n## My Includes\r\n\r\nThe ***`myIncludes()`*** method determines whether an array includes a certain value among its entries, returning true or false as appropriate.\r\n\r\n* ***`valueToFind`*** - The value to be looked for.\r\n* ***`fromIndex`*** - The index currentValue in the array.\r\n\r\n```js\r\nArray.prototype.myIncludes = function(valueToFind, fromIndex = 0) {\r\nlet result = false;\r\nfor (let i = fromIndex; i < this.length; i++) {\r\nif(this[i] === valueToFind) {\r\nresult = true;\r\n}\r\n}\r\nreturn result;\r\n}\r\n```\r\nExample :-\r\n```js\r\nconsole.log([1, 2, 3, 4].myIncludes(1));\r\n//true\r\n```\r\nOR\r\n```js\r\nconsole.log([1,2,3,4].myIncludes(4,3));\r\n//true\r\n```\r\n\r\n## My Filter\r\nThe ***`myFilter()`*** method creates a new array with all elements that pass the test implemented by the provided function.\r\n\r\n* ***`callback`*** - Function to execute on each element. It accepts between one and three arguments:\r\n    * ***`currentValue`*** - The current element being processed in the array.\r\n    * ***`index Optional`*** - The index currentValue in the array.\r\n    * ***`array Optional`*** - The array myFilter() was called upon.\r\n\r\n```js\r\nArray.prototype.myFilter = function(f) {\r\nlet result = [];\r\nfor (let i = 0; i < this.length; i++) {\r\nif(f(this[i], i, this)) {\r\nresult.push(this[i]);\r\n}\r\n}\r\nreturn result;\r\n}\r\n```\r\nExample :-\r\n```js\r\nconst cars = ['BMW', 'Suzuki', 'Mercedes', 'Honda', 'Mahindra', 'Tata'];\r\n\r\nconst result = cars.myFilter(item => item.length>5);\r\n```\r\nThis results in-\r\n```js\r\n['Suzuki', 'Mercedes', 'Mahindra']\r\n```\r\n\r\n## My Reducer Function\r\nThe ***`myReduce()`*** method executes a reducer function (that you provide) on each element of the array, resulting in a single output value.\r\n\r\n* ***`callback`*** - Function to execute on each element. It accepts two arguments\r\n* ***`initialValue`*** - To be passed in to the callback function\r\n    * ***`startValue`*** - The value to start from in the callback function.\r\n    * ***`currentValue`*** - The value that is present in the loop.\r\n\r\n```js\r\nArray.prototype.myReduce = function(f, initialValue) {\r\nlet result = initialValue;\r\nfor (let i = 0; i < this.length; i++) {\r\nresult = f(result, this[i]);\r\n}\r\nreturn result;\r\n}\r\n```\r\nExample :-\r\n```js\r\nlet arr = [1, 2, 3, 4];\r\nconsole.log(arr.myReduce((a,c) => a + c, 5));\r\n```\r\nThis resullts in -\r\n```js\r\n15\r\n/* initialValue = 5\r\nfunction performs the function of adding all the array elements\r\nresult = 5 + 1 + 2 + 3 + 4 = 15 */\r\n```"},{"id":1657737000,"title":"Inheritance in JavaScript\r","author":"MSP\r","date":"July 14, 2022\r","content":"\r\n## What is **`Inheritance`**?\r\n\r\n`In object-oriented programming, inheritance is the mechanism of basing an object or class upon another object (prototype-based inheritance) or class, retaining similar implementation` . Also defined as deriving new classes (sub classes) from existing ones such as super class or base class and then forming them into a hierarchy of classes.\r\n\r\n In most class-based object-oriented languages, an object created through inheritance, a `child object` , acquires all the properties and behaviors of the `parent object` , with the exception of constructors, destructor, overloaded operators and friend functions of the base class.\r\n \r\n Inheritance allows programmers to create classes that are built upon existing classes, to specify a new implementation while maintaining the same behaviors, to reuse code and to independently extend original software via public classes and interfaces.\r\n\r\n ## What is *`class`*?\r\nA *`class`* is a definition for an *`object`*. All objects are created from classes and can't exist without them. A class holds information or details about an object. In `object oriented programming` classes are used like a **blueprint** or **template** to create new objects from.\r\n\r\n## What is *`object`*\r\n\r\nIn object oriented programming we combine a group of related variables and functions into a unit, we call that unit an **`object`**. We refer to these variables as properties and functions as methods.\r\n\r\n**In JavaScript, inheritance is supported by using prototype object. Some people call it** ***`Prototypal Inheritance`*** **and some call it** ***`Behaviour of Delegation`***\r\n\r\n## Difference between Class and Prototypal Inheritance\r\n\r\n**Class Inheritannce:** ***A class is like a blueprint--a description of the object to be created.*** Classes inherit from classes and *create subclass relationships:*hierarchical class taxonomies(classification).\r\n\r\nInstances are typically instantiated via constructor functions with the `new` keyword. Class inheritance may or may not use the `class` keyword from ES6. Classes as you may know them from languages like Java don’t technically exist in JavaScript. Constructor functions are used, instead. The ES6 `class` keyword desugars to a constructor function:\r\n```bash\r\nclass Foo {}\r\ntypeof Foo // 'function'\r\n```\r\nIn JavaScript, class inheritance is implemented on top of prototypal inheritance, but that does not mean that it does the same thing:\r\nJavaScript’s class inheritance uses the prototype chain to wire the child `Constructor.prototype` to the parent `Constructor.prototype` for delegation. Usually, the `super()` constructor is also called. Those steps form **single-ancestor parent/child hierarchies and create the tightest coupling available in OO design.**\r\n\r\n**Prototypal Inheritance:** ***A prototype is a working object instance.*** Objects inherit directly from other objects.\r\n\r\nInstances may be composed from many different source objects, allowing for easy selective inheritance and a flat [Prototype] delegation hierarchy. In other words, class taxonomies are not an automatic side-effect of prototypal OO: a critical distinction.\r\nInstances are typically instantiated via factory functions, object literals, or *`Object.create()`*.\r\n\r\n*`Inheritance is fundamentally a code reuse mechanism: A way for different kinds of objects to share code. The way that you share code matters because if you get it wrong, it can create a lot of problems.`*\r\n\r\n**Class inheritance creates parent/child object taxonomies as a side-effect.**\r\n\r\nThose taxonomies are virtually impossible to get right for all new use cases, and widespread use of a base class leads to the fragile base class problem, which makes them difficult to fix when you get them wrong. In fact, class inheritance causes many well known problems in OO design:\r\n1. **The tight coupling problem-** (class inheritance is the tightest coupling available in oo design) Tight coupling in general is when two things depends on one another, that is, changing one may have impact on another., which leads to the next one…\r\n2. ***The fragile base class problem-**The fragile base class problem is a fundamental architectural problem of object-oriented programming systems where base classes (superclasses) are considered \"fragile\" because seemingly safe modifications to a base class, when inherited by the derived classes, may cause the derived classes to malfunction.\r\n3. **Inflexible hierarchy problem** (eventually, all evolving hierarchies are wrong for new uses)\r\n4. **The duplication by necessity problem** (due to inflexible hierarchies, new use cases are often shoe-horned in by duplicating, rather than adapting existing code)\r\n5. **The Gorilla/banana problem** (What you wanted was a banana, but what you got was a gorilla holding the banana, and the entire jungle)"},{"id":1657391400,"title":"Cloning an Object\r","author":"MSP\r","date":"July 10, 2022\r","content":"\r\nHere we are going to create a function which will clone or copy an object to another object.\r\n\r\nIf the Object only contains primitive value such as **`strings`**, **`numbers`**, **`booleans`** etc. We can use the function ***`Object.assign()`***. \r\n\r\n***`Object.assign()`*** function takes two arguments -\r\n1. new object which is going to be generated\r\n2. source object from which the data is to be copied.\r\n\r\nExample:- \r\n```js\r\nlet swift = {\r\n    brand: 'Maruti',\r\n    fuel: 'petrol',\r\n    doors: 4,\r\n    type: 'hatchback'\r\n};\r\n\r\nlet baleno = {};\r\n\r\nObject.assign(baleno, swift);\r\n\r\nbaleno.type = 'premium hatchback';\r\n\r\nconsole.log(baleno, swift);\r\n```\r\nThis results in:-\r\n```js\r\n{brand: \"Maruti\", fuel: \"petrol\", doors: 4, type: \"hatchback\"}\r\n{brand: \"Maruti\", fuel: \"petrol\", doors: 4, type: \"premium hatchback\"}\r\n```\r\nThis solution does not allows us to peform deep cloning. *Deep Cloning* stands for copying the object which contains objects inside it as its properties.\r\nFor that purpose we can use ***`JSON.parse(JSON.stringify(source_object))`***. This method first converts the whole `source-object` into a string and then parse(resolve into its component parts) it to another object.\r\n\r\nApart from doing the above two we can simply create our own function that will do the same using the recursion.\r\nFor Example:-\r\n```js\r\nlet bmw = {\r\n  model: 'x4',\r\n  fuel: 'petrol',\r\n  engine: {\r\n  \ttype: 'v6'\r\n  }\r\n}\r\n\r\nlet car = {};\r\n\r\nfunction clone(src){\r\n    let result = {};\r\n    let keys = Object.keys(src);\r\n    //['model', 'fuel', 'engine'];\r\n    keys.forEach(key => {\r\n        if(typeof src[key] === \"object\") {\r\n            result[key] = clone(src[key]);\r\n        }else {\r\n            result[key] = src[key];\r\n        }\r\n    })\r\n  return result;\r\n}\r\n\r\ncar = clone(bmw);\r\n\r\ncar.fuel = 'disel';\r\ncar.engine.type='v8';\r\n\r\nconsole.log(car,bmw);\r\n```\r\nThis results in-\r\n```js\r\n{model: \"x4\", fuel: \"disel\", engine: {type: \"v8\"}}\r\n{model: \"x4\", fuel: \"petrol\", engine: {type: \"v6\"}}\r\n```\r\nIn this we are providing an **`if statement`** which compares the keys inside the object and if the key returns value equal to the `object` we will call the same function again, but this time inside the conditional statement."},{"id":1657305000,"title":"Undefined vs Not Defined!\r","author":"MSP\r","date":"July 9, 2022\r","content":"In JavaScript if you try to use a variable that doesn't exist and has not been declared, then JavaScript will throw an error `var name is not defined` and the script will stop executing thereafter. But If you use `typeof undeclared_variable` then it will return `undefined`.\r\n\r\nBefore starting further discussion let's understand the difference between declaration and definition.\r\n\r\n`var x` is a declaration because you are not defining what value it holds yet, but you are declaring its existence and the need for memory allocation.\r\n\r\n```bash\r\nlet x; // declaring x\r\nconsole.log(x); // output: undefined\r\n```\r\n`var x = 1` is both declaration and definition (also we can say we are doing initialisation), Here declaration and assignment of value happen inline for variable x, In JavaScript every variable declaration and function declaration brings to the top of its current scope in which it's declared then assignment happen in order this term is called *`hoisting`*.\r\n\r\nA variable can be declared but not defined. When we try to access it, It will result `undefined`.\r\n```bash\r\nvar x; // Declaration\r\ntypeof x === 'undefined'; // Will return true\r\n```\r\nA variable can be neither declared nor defined. When we try to reference such variable then the result will be not defined.\r\n```bash\r\nconsole.log(y);  // Output: ReferenceError: y is not defined\r\n```"}]